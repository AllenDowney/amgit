# The second use case #

## Outline ##

This chapter presents another use case for version control with Git.

Suppose you are working on a project and
you have a folder that contains your project files.  When you started
the project, you didn't bother with version control, but now it
looks like the project will be around for a while, and you want to
keep track of your changes.  Or you are worried about
losing work and you want to make a remote copy.  Or a collaborator
has joined the project and you want to share your files.

It is time to bring the project under version control.

For this example, I am going to dig out an old project of
mine called `clink`, which is a network measurement tool I wrote
in grad school.  It is based on `pathchar`, a tool written by
network researcher Van Jacobson.  You can read about `pathchar`
at http://www.caida.org/tools/utilities/others/pathchar/, and
about clink at http://allendowney.com/research/clink/.

If you want to follow along with this example, choose any folder on
your system that contains a few files.


## Initialize the repo ##

`cd` into your project folder and type

    $ git init

Git responds

    Initialized empty Git repository in /home/downey/clink/.git/

Congratulations!  Your project is now under version control.  Git
created a `.git` folder that contains the Object store and the
Index.  You can now think of your project folder as a Git
repository.

At this point the Object store and the Index are empty,
and Git doesn't actually know about any of your project files yet.

If you type

    $ git status

Git responds

    # On branch master
    #
    # Initial commit
    #
    # Untracked files:
    #   (use "git add <file>..." to include in what will be committed)
    #
    #	COPYRIGHT
    #	Makefile
    #	Makefile~
    #	clink
    ...
    #	util.c
    #	util.c~
    #	util.o
    #	var/
    nothing added to commit but untracked files present (use "git add" to track)

A file is "untracked" if it is in the project folder but you have
never told Git to keep track of it.  Helpfully, the status message
tells you how to start tracking files.  Unhelpfully, it doesn't
tell you which files to track.


## Adding files ##

In general, it is a good idea to track files that you write and
edit, and it is a good idea _not_ to track files that are generated
by compilers and other programs.

You should include all files that someone else would need
to clone your repo and rebuild the project.  So you should include
source code and Makefiles, but not object files and executables.

Here's a complete list of the files
in my project folder:

   clink             collect.c   hack       notes       process.o   util.c
   clink.1.0         collect.c~  hack.tar   notes.txt   README.txt  util.c~
   clink.1.0.tar     collect.o   icmp.c     notes.txt~  tos         util.o
   clink.1.0.tar.gz  COPYRIGHT   Makefile   process.c   udp.c       var
   clink.h           data        Makefile~  process.c~  unpv12e

For many of these files, I know whether to track them based on their
names.  Files I should track:

*  Source files ending in `.c` and `.h` are source files.
* `Makefile`, `notes`, `notes`, `notes.txt`, `COPYRIGHT` and `README.txt`
are all files I created and edited by hand.

Files I should not track:

*  `clink` is an executable.
*  Files ending in `.o` are generated by the compiler. 
*  Files ending in `~` are backup files generated by emacs.
*  `clink.1.0` and the `tar` files are created by `make`.

The `data` folder contains data I collected with `clink`.  Whether
or not I should track it depends on what I plan to do with it.
If I am planning to process the data and include the results in a
paper, I should definitely track it.  But I collected this data
years ago while I was debugging `clink`, so I don't really need
it.

`var`, `tos`, `hack` (and `hack.tar`) are all versions of `clink`
I wrote in order to test different algorithms.  If I were using
version control at the time, they would have been branches (which
we will see soon).  I don't remember what's in any of them, so
I won't track them.

Finally, `unpv12e` contains a copy of the code from Stevens's
excellent book _Unix Network Programming, Volume 1: The Sockets
Networking API (2nd Edition)_.  My file `util.c` contains modified
versions of this code, but I don't need the original code any more,
and I don't think I am supposed to redistribute it, so I won't add it
to the repo.

This might be more than you need to know about my project, but
it provides a realistic example.

Now I can add the files I want to track:

    $ git add *.c *.h COPYRIGHT Makefile notes notes.txt README.txt

If I run

    $ git status

Git responds

    # On branch master
    #
    # Initial commit
    #
    # Changes to be committed:
    #   (use "git rm --cached <file>..." to unstage)
    #
    #	new file:   COPYRIGHT
    ...
    #	new file:   util.c
    #
    # Untracked files:
    #   (use "git add <file>..." to include in what will be committed)
    #
    #	Makefile~
    ...
    #	var/

At this point I have added 11 files, and there are several more
files that are still untracked.

The files I added are in the Index now, but they are not yet in
the Object store.  Files in this state are called "staged," and
they are said to be in the "staging area."


## Staging files ##

Here's how the staging area is typically used:

1.     Use `git add` to stage files.
2.     Use `git status` to confirm that the staging area contains
the files you want to commit.
3.     Use `git commit` to copy the staged files into the Object store.

If the staging area contains the files you want to commit, type

    $ git commit -m "Adding source files"

Git responds

    [master (root-commit) 9e9cc98] Adding source files
     11 files changed, 5304 insertions(+)
     create mode 100644 COPYRIGHT
     ...
     create mode 100644 util.c

If you add a file to the staging area and then change your mind,
you can use `git reset` to remove it from the staging area.

As an example, I will add the executable `clink`:

    $ git add clink

And then

    $ git status

Git responds

    # On branch master
    # Changes to be committed:
    #   (use "git reset HEAD <file>..." to unstage)
    #
    #	new file:   clink

Helpfully, git tells me how to unstage files:

    $ git reset HEAD clink

Running `git status` again confirms that it is no longer staged.

I would love to explain exactly what `reset` does and why this
command has the effect of unstaging a file, but it would take
a long time and give both of us a headache.

For now, I suggest you treat this command as a magical incantation.
If you know what it does, and when to use it, you don't have to
understand how it works.

If you really want to know, this page does a better job of
explaining it than anything else I have seen:
http://git-scm.com/2011/07/11/reset.html


## Adding folders ##

If you add a folder, Git adds every file in the folder, and every
file in its subfolders, and so on, recursively.  That's usually not
what you want, so be careful.

Normally you don't have to add folders explicitly.  Instead, you just
add the files you want to add.  If they are in subfolders, Git
deals with it.

As an example, I'll add `hack/hack.html`:

    $ git add hack/hack.html
    $ git commit -m "Adding hack.html"
    [master b3845f6] Adding hack.html
     1 file changed, 87 insertions(+)
     create mode 100644 hack/hack.html

Or you can `cd` into a subfolder and add the files you want.


## Ignoring files ##

Although there are lots of good reasons for keeping untracked
files in your project folder, Git has a tendency to nag you about
them.  Every time you run `git status`, there they are!

Fortunately, there is a way to get Git off your back.  You can create
a file named `.gitignore` and list the files you want Git to ignore.
If you include UNIX-style wildcard patterns, Git ignores any file that
matches the patterns.

My `.gitignore` includes these patterns

    *.o
    *~
    *.tar
    *.gz

And the names of the files and folders I want to leave untracked.

Of course, once you create `.gitignore`, you should add it to the
repo.

    $ git add .gitignore
    $ git commit -m "Adding .gitignore"


## Going remote ##

At this point your project is under version control in a local
repository.  But the local repo is not connected to a remote repo,
so if your hard drive crashes, you are out of luck.

So the next steps are

1.  Create a remote repository on Github or another server.
2.  Connect your local repo to the remote.
3.  Push the last commit from your local repo to the remote.


## Creating a repo on Github ##

On your GitHub home page you should see a list of your repositories in
the lower right corner.  Click on the green button that
says "New Repository".

Give your repo a name.  I named mine `clink`.
People use different schemas for project
names.  Your project name will appear in URLs, so you should keep it
short.  You can't use spaces; most people use hyphens between
lower-case words, `like-this`, or mash capitalized words together,
`LikeThis`.

In the description field, write a sentence to describe your project.
You can make the project public or private.  To create a private
repository, you might have to upgrade your account, which is a
delicate way to say you might have to pay.

Do not click on the button that says "Initialize
the repository with a README".

Click "Create repository".  You will be taken to a "Quick setup" page
with instructions for pushing an existing repository from the
command line, which is exactly what we want to do.

For my project, I run

    $ git remote add origin https://github.com/AllenDowney/clink.git

Of course, your project has a different URL.

This command tells Git to connect the local repo to the remote
repo, and to refer to the remote repo as `origin`, which is a
name used by convention to indicate that the remote repo is the
origin of the local copy, even though in this case it's the other
way around.

Now we can push a set of commits from the local repo to the remote:

    $ git push -u origin master

The `-u` option has the effect of configuring the remote repo as if
we had cloned it.  You only need `-u` for the first push.  After
that, everything is the same as if we had cloned the remote
repo.

If you reload the project home page on GitHub, you should see
the files you just pushed.


